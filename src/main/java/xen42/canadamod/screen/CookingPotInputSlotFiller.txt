package xen42.canadamod.screen;

import java.util.List;

import net.minecraft.entity.player.PlayerInventory;
import net.minecraft.recipe.RecipeEntry;
import net.minecraft.recipe.RecipeFinder;
import net.minecraft.screen.AbstractRecipeScreenHandler;
import net.minecraft.screen.slot.Slot;
import xen42.canadamod.recipe.CookingPotRecipe;
import xen42.canadamod.recipe.CookingPotRecipeInput;

public class CookingPotInputSlotFiller {
    private final Slot brimstoneSlot;
    private final List<Slot> inputSlots;
    private final List<Slot> slotsToReturn;
    private final PlayerInventory inventory;
    private final RecipeEntry<CookingPotRecipe> recipe;
    private final boolean craftAll;
    private final boolean creative;
    
    public CookingPotInputSlotFiller(
        Slot brimstoneSlot,
            List<Slot> inputSlots,
            PlayerInventory inventory,
            RecipeEntry<CookingPotRecipe> recipe,
            boolean craftAll,
            boolean creative
        ) {
        this(brimstoneSlot, inputSlots, inputSlots, inventory, recipe, craftAll, creative);
    }
    
    public CookingPotInputSlotFiller(
        Slot brimstoneSlot,
            List<Slot> inputSlots,
            List<Slot> slotsToReturn,
        PlayerInventory inventory,
        RecipeEntry<CookingPotRecipe> recipe,
        boolean craftAll,
            boolean creative
        ) {
        this.brimstoneSlot = brimstoneSlot;
        this.inputSlots = inputSlots;
        this.slotsToReturn = slotsToReturn;
        this.inventory = inventory;
        this.recipe = recipe;
        this.craftAll = craftAll;
        this.creative = creative;
    }
    
    public AbstractRecipeScreenHandler.PostFillAction fill() {
        if (!creative && !canReturnInputs()) {
            return AbstractRecipeScreenHandler.PostFillAction.NOTHING;
        } else {
            RecipeFinder recipeFinder = new RecipeFinder();
            inventory.populateRecipeFinder(recipeFinder);
            populateRecipeFinder(recipeFinder);
            return tryFill(recipe, recipeFinder);
        }
    }

    public void clear() {
        this.inventory.clear();
    }

    public boolean matches(RecipeEntry<CookingPotRecipe> entry) {
        return entry.value()
            .matches(CookingPotRecipeInput.create(this.inventory.getHeldStacks()), getPlayer().getWorld());
    }

    private AbstractRecipeScreenHandler.PostFillAction tryFill(RecipeEntry<EffigyAltarRecipe> recipe, RecipeFinder finder) {
        if (finder.isCraftable(recipe.value(), null)) {
            this.fill(recipe, finder);
            this.inventory.markDirty();
            return AbstractRecipeScreenHandler.PostFillAction.NOTHING;
        } else {
            this.returnInputs();
            this.inventory.markDirty();
            return AbstractRecipeScreenHandler.PostFillAction.PLACE_GHOST_RECIPE;
        }
    }

    private void returnInputs() {
        for (Slot slot : this.slotsToReturn) {
            ItemStack itemStack = slot.getStack().copy();
            this.inventory.offer(itemStack, false);
            slot.setStackNoCallbacks(itemStack);
        }
        
        ItemStack brimstoneStack = brimstoneSlot.getStack().copy();
        this.inventory.offer(brimstoneStack, false);
        brimstoneSlot.setStackNoCallbacks(brimstoneStack);

        clear();
    }

    private void fill(RecipeEntry<EffigyAltarRecipe> recipe, RecipeFinder finder) {
        boolean match = matches(recipe);
        int i = finder.countCrafts(recipe.value(), null);
        if (match) {
            ItemStack brimstoneItemStack = brimstoneSlot.getStack();
            if (!brimstoneItemStack.isEmpty() && Math.min(i, brimstoneItemStack.getMaxCount()) < brimstoneItemStack.getCount() + 1) {
                return;
            }
            for (Slot slot : this.inputSlots) {
                ItemStack itemStack = slot.getStack();
                if (!itemStack.isEmpty() && Math.min(i, itemStack.getMaxCount()) < itemStack.getCount() + 1) {
                    return;
                }
            }
        }

        int j = this.calculateCraftAmount(i, match);
        List<RegistryEntry<Item>> entries = new ArrayList<RegistryEntry<Item>>();
        boolean isCraftable = finder.isCraftable(recipe.value(), j, entries::add);
        if (isCraftable) {
            int k = clampToMaxCount(j, entries);
            if (k != j) {
                entries.clear();
                if (!finder.isCraftable(recipe.value(), k, entries::add)) {
                    return;
                }
            }

            this.returnInputs();
            EffigyAltarRecipe recipeValue = recipe.value();
            IntList placementSlots = recipeValue.getIngredientPlacement().getPlacementSlots();
            RegistryEntry<Item> brimstoneRegistryEntry = entries.get(placementSlots.getInt(inputSlots.size()));
            int jk = k;

            while (jk > 0) {
                jk = this.fillInputSlot(brimstoneSlot, brimstoneRegistryEntry, jk);
                if (jk == -1) {
                    return;
                }
            }
            for (int index = 0; index < inputSlots.size(); index++) {
                Slot slot = inputSlots.get(index);
                int placementSlot = placementSlots.getInt(index);
                RegistryEntry<Item> registryEntry = entries.get(placementSlot);
                int jx = k;

                while (jx > 0) {
                    jx = this.fillInputSlot(slot, registryEntry, jx);
                    if (jx == -1) {
                        return;
                    }
                }
            }
        }
    }

    private static int clampToMaxCount(int count, List<RegistryEntry<Item>> entries) {
        for (RegistryEntry<Item> registryEntry : entries) {
            count = Math.min(count, registryEntry.value().getMaxCount());
        }

        return count;
    }

    private int calculateCraftAmount(int forCraftAll, boolean match) {
        if (this.craftAll) {
            return forCraftAll;
        } else if (match) {
            int i = Integer.MAX_VALUE;

            for (Slot slot : this.inputSlots) {
                ItemStack itemStack = slot.getStack();
                if (!itemStack.isEmpty() && i > itemStack.getCount()) {
                    i = itemStack.getCount();
                }
            }

            if (i != Integer.MAX_VALUE) {
                i++;
            }

            return i;
        } else {
            return 1;
        }
    }

    private int fillInputSlot(Slot slot, RegistryEntry<Item> item, int count) {
        ItemStack itemStack = slot.getStack();
        int i = this.inventory.getMatchingSlot(item, itemStack);
        if (i == -1) {
            return -1;
        } else {
            ItemStack itemStackAtIndex = this.inventory.getStack(i);
            ItemStack itemStack3;
            if (count < itemStackAtIndex.getCount()) {
                itemStack3 = this.inventory.removeStack(i, count);
            } else {
                itemStack3 = this.inventory.removeStack(i);
            }

            int j = itemStack3.getCount();
            if (itemStack.isEmpty()) {
                slot.setStackNoCallbacks(itemStack3);
            } else {
                itemStack.increment(j);
            }

            return count - j;
        }
    }

    private boolean canReturnInputs() {
        List<ItemStack> list = Lists.<ItemStack>newArrayList();
        int i = this.getFreeInventorySlots();

        for (Slot slot : this.inputSlots) {
            ItemStack itemStack = slot.getStack().copy();
            if (!itemStack.isEmpty()) {
                int j = this.inventory.getOccupiedSlotWithRoomForStack(itemStack);
                if (j == -1 && list.size() <= i) {
                    for (ItemStack itemStack2 : list) {
                        if (ItemStack.areItemsEqual(itemStack2, itemStack)
                            && itemStack2.getCount() != itemStack2.getMaxCount()
                            && itemStack2.getCount() + itemStack.getCount() <= itemStack2.getMaxCount()) {
                            itemStack2.increment(itemStack.getCount());
                            itemStack.setCount(0);
                            break;
                        }
                    }

                    if (!itemStack.isEmpty()) {
                        if (list.size() >= i) {
                            return false;
                        }

                        list.add(itemStack);
                    }
                } else if (j == -1) {
                    return false;
                }
            }
        }

        return true;
    }

    private int getFreeInventorySlots() {
        int i = 0;

        for (ItemStack itemStack : this.inventory.getMainStacks()) {
            if (itemStack.isEmpty()) {
                i++;
            }
        }

        return i;
    }
}
    
